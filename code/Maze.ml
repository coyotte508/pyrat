(**********************************************************************************************************************************************************************************************************************************)
(******************************************************************************************************** GLOBAL CONSTANTS ********************************************************************************************************)
(**********************************************************************************************************************************************************************************************************************************)

    let _EXPORT_COINS_FILE_NAME =
        
        (* Name of the file where to export the coins locations *)
        "coins.txt"
        
    ;;
    
(**********************************************************************************************************************************************************************************************************************************)

    let _EXPORT_MAZE_FILE_NAME =
        
        (* Name of the file where to export the maze *)
        "maze.txt"
        
    ;;
    
(**********************************************************************************************************************************************************************************************************************************)
(******************************************************************************************************** CLASS DEFINITION ********************************************************************************************************)
(**********************************************************************************************************************************************************************************************************************************)

    class virtual maze =

        (******************************************************************************************************************************************************************************************************************)
        (*************************************************************************************************** INHERITANCE **************************************************************************************************)
        (******************************************************************************************************************************************************************************************************************)
        
            object (self)
        
        (******************************************************************************************************************************************************************************************************************)
        (*************************************************************************************************** ATTRIBUTES ***************************************************************************************************)
        (******************************************************************************************************************************************************************************************************************)

            val mutable _coins =
                
                (* Coins in the maze, added after initialization of the map *)
                []
                
        (******************************************************************************************************************************************************************************************************************)
            
            val mutable _graph =
                
                (* Map of the maze, initialized by child class *)
                Hashtbl.create 0
                
        (******************************************************************************************************************************************************************************************************************)
            
            val mutable _height =
                
                (* Height of the maze, initialized by child class *)
                0
                
        (******************************************************************************************************************************************************************************************************************)
            
            val mutable _initialCoins =
                
                (* Stores the initial coins locations for the final export *)
                []
                
        (******************************************************************************************************************************************************************************************************************)
            
            val mutable _width =
                
                (* Width of the maze, initialized by child class *)
                0
                
        (******************************************************************************************************************************************************************************************************************)
        (************************************************************************************************* VIRTUAL METHODS ************************************************************************************************)
        (******************************************************************************************************************************************************************************************************************)
            
            method virtual generateGraph :
                
                (* Returns the width, height and map of the maze*)
                int * int * ((int * int), ((int * int) * int)) Hashtbl.t
                
        (******************************************************************************************************************************************************************************************************************)
        (************************************************************************************************* PRIVATE METHODS ************************************************************************************************)
        (******************************************************************************************************************************************************************************************************************)
            
            method private tryToMoveDown (location : int * int) =
                
                (* We determine the location if the move is ok *)
                let (currentL, currentC) = location in
                let potentialL = currentL + 1 in
                let potentialC = currentC in
                
                (* We check if the player is not already on the bottom, and if there is no wall *)
                if potentialL <= _height - 1 && not (self#wallBetweenCells (currentL, currentC) (potentialL, potentialC)) then
                    (potentialL, potentialC)
                else
                    (currentL, currentC)
                
        (******************************************************************************************************************************************************************************************************************)
            
            method private tryToMoveLeft (location : int * int) =
                
                (* We determine the location if the move is ok *)
                let (currentL, currentC) = location in
                let potentialL = currentL in
                let potentialC = currentC - 1 in
                
                (* We check if the player is not already on the left, and if there is no wall *)
                if potentialC >= 0 && not (self#wallBetweenCells (currentL, currentC) (potentialL, potentialC)) then
                    (potentialL, potentialC)
                else
                    (currentL, currentC)
                
        (******************************************************************************************************************************************************************************************************************)
            
            method private tryToMoveRight (location : int * int) =
                
                (* We determine the location if the move is ok *)
                let (currentL, currentC) = location in
                let potentialL = currentL in
                let potentialC = currentC + 1 in
                
                (* We check if the player is not already on the right, and if there is no wall *)
                if potentialC <= _width - 1 && not (self#wallBetweenCells (currentL, currentC) (potentialL, potentialC)) then
                    (potentialL, potentialC)
                else
                    (currentL, currentC)
                
        (******************************************************************************************************************************************************************************************************************)
            
            method private tryToMoveUp (location : int * int) =
                
                (* We determine the location if the move is ok *)
                let (currentL, currentC) = location in
                let potentialL = currentL - 1 in
                let potentialC = currentC in
                
                (* We check if the player is not already on the top, and if there is no wall *)
                if potentialL >= 0 && not (self#wallBetweenCells (currentL, currentC) (potentialL, potentialC)) then
                    (potentialL, potentialC)
                else
                    (currentL, currentC)
                
        (******************************************************************************************************************************************************************************************************************)
        (************************************************************************************************* PUBLIC METHODS *************************************************************************************************)
        (******************************************************************************************************************************************************************************************************************)
            
            method coinInCell (cell : int * int) =
                
                (* Indicates if the cell contains a coin *)
                List.mem cell _coins
                
        (******************************************************************************************************************************************************************************************************************)
            
            method coinInitiallyInCell (cell : int * int) =
                
                (* Indicates if the cell contained a coin at the beginning of the game *)
                List.mem cell _initialCoins
                
        (******************************************************************************************************************************************************************************************************************)
            
            method coinsToString =
                
                (* Current coins *)
                ToolBox.listOfIntPairsToString _coins
                
        (******************************************************************************************************************************************************************************************************************)
            
            method countCoins =
                
                (* We count the coins *)
                List.length _coins
                
        (******************************************************************************************************************************************************************************************************************)
            
            method determineLocationAfterMove (move   : char)
                                              (player : Player.player) =
                
                (* We check the letter received to compute the new location *)
                match move with
                    m when m = Moves._UP    -> self#tryToMoveUp player#getCurrentLocation
                  | m when m = Moves._DOWN  -> self#tryToMoveDown player#getCurrentLocation
                  | m when m = Moves._LEFT  -> self#tryToMoveLeft player#getCurrentLocation
                  | m when m = Moves._RIGHT -> self#tryToMoveRight player#getCurrentLocation
                  | _                       -> player#getCurrentLocation
                
        (******************************************************************************************************************************************************************************************************************)
            
            method exportCoins (outputFilesDirectory : string) =
                
                (* We determine the full file name *)
                let fileName = outputFilesDirectory ^ "/" ^ _EXPORT_COINS_FILE_NAME in
                
                (* We open the file and write the coins locations to it *)
                let channel = open_out fileName in
                Printf.fprintf channel "%s\n" (ToolBox.listOfIntPairsToString _initialCoins);
                close_out channel
                
        (******************************************************************************************************************************************************************************************************************)
            
            method exportMaze (outputFilesDirectory : string) =
                
                (* We determine the full file name *)
                let fileName = outputFilesDirectory ^ "/" ^ _EXPORT_MAZE_FILE_NAME in
                
                (* We open the file and write the maze to it *)
                let channel = open_out fileName in
                Printf.fprintf channel "%s\n" self#mazeToString;
                close_out channel
                
        (******************************************************************************************************************************************************************************************************************)
            
            method getCoins =
                
                (* Getter for the coins *)
                _coins
                
        (******************************************************************************************************************************************************************************************************************)
            
            method getHeight =
                
                (* Getter for the height *)
                _height
                
        (******************************************************************************************************************************************************************************************************************)
            
            method getWidth =
                
                (* Getter for the width *)
                _width
                
        (******************************************************************************************************************************************************************************************************************)
            
            method initialize =
                
                (* We use the method implemented by the child class *)
                let (width, height, graph) = self#generateGraph in
                _width <- width;
                _height <- height;
                _graph <- graph
                
        (******************************************************************************************************************************************************************************************************************)
            
            method mazeToString =
                
                (* We fill a string representing the maze *)
                let representation = ref "" in
                let encounteredCells = ref [] in
                let hashtblToString = fun cell _ ->
                                      (
                                          if not (List.mem cell !encounteredCells) then
                                          (
                                              encounteredCells := cell :: !encounteredCells;
                                              representation := !representation ^ ToolBox.intPairToString cell ^ ":[";
                                              let neighborsToString = fun neighbor ->
                                                                      (
                                                                          representation := !representation ^ "(" ^ ToolBox.intPairToString (fst neighbor) ^ ", " ^ string_of_int (snd neighbor) ^ "), "
                                                                      ) in
                                              List.iter neighborsToString (Hashtbl.find_all _graph cell);
                                              representation := String.sub !representation 0 (String.length !representation - 2) ^ "], "
                                          )
                                      ) in
                Hashtbl.iter hashtblToString _graph;
                representation := "{" ^ String.sub !representation 0 (String.length !representation - 2) ^ "}";
                
                (*Result *)
                !representation
                
        (******************************************************************************************************************************************************************************************************************)
            
            method removeCoin (cell : int * int) =
                
                (* Removes a coin from the maze *)
                let filter = fun coinLocation ->
                             (
                                 coinLocation <> cell
                             ) in
                _coins <- List.filter filter _coins
            
        (******************************************************************************************************************************************************************************************************************)
            
            method setCoins (coins : (int * int) list) =
                
                (* Setter for the coins *)
                _coins <- coins;
                _initialCoins <- _coins
                
        (******************************************************************************************************************************************************************************************************************)
            
            method wallBetweenCells (cell1 : int * int)
                                    (cell2 : int * int) =
                
                (* We check if the two cells are connected *)
                let found = ref false in
                let lookForCell2 = fun neighbor ->
                                   (
                                       found := !found || (fst neighbor = cell2)
                                   ) in
                List.iter lookForCell2 (Hashtbl.find_all _graph cell1);
                not !found
                
        (******************************************************************************************************************************************************************************************************************)
            
            method weightBetweenCells (cell1 : int * int)
                                      (cell2 : int * int) =
                
                (* We return the weight to go from one cell to the other *)
                let weight = ref 0 in
                let lookForCell2 = fun neighbor ->
                                   (
                                       if fst neighbor = cell2 then
                                           weight := snd neighbor
                                   ) in
                List.iter lookForCell2 (Hashtbl.find_all _graph cell1);
                
                (* We return 0 if the cells are not connected *)
                !weight
                
        (******************************************************************************************************************************************************************************************************************)
        (******************************************************************************************************************************************************************************************************************)
        
    end
    
(**********************************************************************************************************************************************************************************************************************************)
(**********************************************************************************************************************************************************************************************************************************)